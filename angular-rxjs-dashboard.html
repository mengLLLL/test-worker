<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Angular+RxJS实时数据仪表盘模拟</title>
    <!-- 引入Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- 引入RxJS -->
    <script src="https://unpkg.com/rxjs@7.5.5/dist/bundles/rxjs.umd.min.js"></script>
    <style>
        .chart-container {
            height: 300px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        .log-container {
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        .stats-card {
            height: 100%;
            font-size: 14px;
        }
        .worker-card {
            margin-bottom: 10px;
            font-size: 14px;
        }
        .chart-svg {
            width: 100%;
            height: 250px;
        }
        .badge-data {
            margin-right: 5px;
        }
        .debug { color: #6c757d; }
        .info { color: #0d6efd; }
        .warn { color: #ffc107; }
        .error { color: #dc3545; }
        .log-entry {
            margin: 2px 0;
            padding: 2px;
            border-bottom: 1px solid #eee;
        }
        /* 添加路径动画 */
        .data-line {
            transition: d 0.3s ease;
        }
        /* 添加SVG元素过渡效果 */
        .chart-svg text, .chart-svg line {
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- 顶部导航栏 -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">Angular+RxJS实时数据仪表盘</a>
            <div class="d-flex">
                <button id="startBtn" class="btn btn-success me-2">开始</button>
                <button id="stopBtn" class="btn btn-danger me-2" disabled>停止</button>
                <button id="importBtn" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#importModal">导入数据</button>
            </div>
        </div>
    </nav>

    <!-- 主体内容 -->
    <div class="container-fluid mt-3">
        <div class="row">
            <!-- 图表区域 -->
            <div class="col-md-9">
                <div class="row">
                    <div class="col-12">
                        <div class="chart-container">
                            <h5>数据流A</h5>
                            <svg id="chart-a" class="chart-svg"></svg>
                        </div>
                    </div>
                    <div class="col-12">
                        <div class="chart-container">
                            <h5>数据流B</h5>
                            <svg id="chart-b" class="chart-svg"></svg>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 状态面板 -->
            <div class="col-md-3">
                <!-- 统计信息 -->
                <div class="card mb-3">
                    <div class="card-header bg-primary text-white">
                        <h5 class="card-title m-0">统计信息</h5>
                    </div>
                    <div class="card-body" id="statsPanel"></div>
                </div>

                <!-- Worker状态 -->
                <div class="card mb-3">
                    <div class="card-header bg-primary text-white">
                        <h5 class="card-title m-0">Worker状态</h5>
                    </div>
                    <div class="card-body" id="workerStatusPanel"></div>
                </div>

                <!-- 系统日志 -->
                <div class="card">
                    <div class="card-header bg-primary text-white">
                        <h5 class="card-title m-0">系统日志</h5>
                    </div>
                    <div class="card-body p-0">
                        <div id="logContainer" class="log-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 导入数据弹窗 -->
    <div class="modal fade" id="importModal" tabindex="-1" aria-labelledby="importModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="importModalLabel">导入外部数据</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="dataTypeSelect" class="form-label">选择数据类型</label>
                        <select class="form-select" id="dataTypeSelect">
                            <option value="dataA">数据流A</option>
                            <option value="dataB">数据流B</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="jsonDataInput" class="form-label">JSON数据</label>
                        <textarea class="form-control" id="jsonDataInput" rows="10" placeholder='[{"x": 1, "y": 100}, {"x": 2, "y": 150}]'></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">取消</button>
                    <button type="button" class="btn btn-primary" id="importDataBtn">导入</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 引入Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // 使用RxJS命名空间
        const { 
            of, from, fromEvent, interval, merge, concat, combineLatest, 
            Subject, BehaviorSubject, ReplaySubject, 
            map, filter, tap, mergeMap, switchMap, concatMap, 
            debounceTime, throttleTime, distinctUntilChanged,
            catchError, retry, finalize, 
            takeUntil, take, skip, scan
        } = rxjs;

        // --------------------------
        // 工具函数
        // --------------------------
        
        // 日志系统
        const logSubject = new Subject();
        
        function log(message, level = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            logSubject.next({ message, level, timestamp });
        }
        
        // 创建数据点
        function createDataPoint(x, y) {
            return { x, y };
        }
        
        // 生成随机数据
        function generateRandomData(count, startX = 0) {
            return Array.from({ length: count }, (_, i) => {
                const x = startX + i;
                const y = Math.floor(Math.random() * 100) + 50;
                return createDataPoint(x, y);
            });
        }

        // --------------------------
        // Worker相关代码
        // --------------------------
        
        // 工作线程代码 (字符串形式，将通过Blob创建)
        const workerScript = `
            // Worker内部处理函数
            function processData(data, dataType) {
                try {
                    // 模拟处理时间 - 减少模拟处理延迟
                    const startTime = Date.now();
                    
                    // 降低错误概率从0.05到0.01
                    if (Math.random() < 0.01) {
                        throw new Error(dataType + "数据处理中的模拟随机错误");
                    }
                    
                    // 数据处理逻辑 - 计算统计量
                    let sum = 0;
                    let sumSquared = 0;
                    let min = Infinity;
                    let max = -Infinity;
                    
                    // 预先计算数据长度，避免循环中重复计算
                    const dataLength = data.length;
                    
                    // 使用更高效的数组方法
                    const processedData = new Array(dataLength);
                    
                    // 第一遍循环计算统计量
                    for (let i = 0; i < dataLength; i++) {
                        const y = data[i].y;
                        sum += y;
                        sumSquared += y * y;
                        min = y < min ? y : min;
                        max = y > max ? y : max;
                    }
                    
                    // 计算统计摘要
                    const count = dataLength;
                    const mean = sum / count;
                    const variance = sumSquared / count - mean * mean;
                    const stdDev = Math.sqrt(variance);
                    
                    // 第二遍循环生成处理后的数据
                    for (let i = 0; i < dataLength; i++) {
                        const item = data[i];
                        const y = item.y;
                        
                        processedData[i] = {
                            x: item.x,
                            y: y,
                            original: y,
                            // 添加一些派生值
                            yNorm: (y - min) / (max - min || 1),
                            trend: item.x > 0 ? y - data[0].y : 0
                        };
                    }
                    
                    // 计算处理时间
                    const processingTime = Date.now() - startTime;
                    
                    // 返回处理结果
                    return {
                        success: true,
                        dataType: dataType,
                        processedData: processedData,
                        stats: {
                            count,
                            min,
                            max,
                            mean,
                            stdDev,
                            processingTime
                        }
                    };
                } catch (error) {
                    // 捕获并返回错误
                    return {
                        success: false,
                        dataType: dataType,
                        error: error.message
                    };
                }
            }
            
            // 监听主线程消息
            self.addEventListener('message', function(e) {
                const { taskId, dataType, data } = e.data;
                
                // 处理数据
                const result = processData(data, dataType);
                result.taskId = taskId; // 保持任务ID一致
                
                // 返回结果给主线程
                self.postMessage(result);
            });
        `;
        
        // WorkerPool类 - 管理工作线程
        class WorkerPool {
            constructor(workerCount = navigator.hardwareConcurrency || 4) {
                this.workers = [];
                this.taskQueue = [];
                this.workerCount = workerCount;
                this.nextTaskId = 1;
                
                // 任务结果Subject (用于RxJS流)
                this.resultSubject = new Subject();
                
                // 工作线程状态Subject
                this.workersStatusSubject = new BehaviorSubject([]);
                
                // 初始化工作线程
                this.initWorkers();
                
                // 定期更新工作线程状态
                setInterval(() => this.updateWorkerStatus(), 100);
            }
            
            // 初始化工作线程
            initWorkers() {
                const blob = new Blob([workerScript], { type: 'application/javascript' });
                const workerUrl = URL.createObjectURL(blob);
                
                for (let i = 0; i < this.workerCount; i++) {
                    const worker = new Worker(workerUrl);
                    
                    worker.id = i + 1;
                    worker.status = 'idle';
                    worker.currentTask = null;
                    
                    worker.addEventListener('message', (event) => {
                        this.handleWorkerMessage(worker, event);
                    });
                    
                    worker.addEventListener('error', (error) => {
                        log('Worker ' + worker.id + ' 错误: ' + error.message, 'error');
                        // 标记工作线程为空闲
                        worker.status = 'idle';
                        worker.currentTask = null;
                        // 检查队列
                        this.processNextTask();
                    });
                    
                    this.workers.push(worker);
                }
                
                log('初始化了 ' + this.workerCount + ' 个工作线程', 'info');
                this.updateWorkerStatus();
            }
            
            // 处理工作线程消息
            handleWorkerMessage(worker, event) {
                const result = event.data;
                
                if (result.success) {
                    log('Worker ' + worker.id + ' 完成了任务 #' + result.taskId + ' (' + result.dataType + ')', 'info');
                } else {
                    log('Worker ' + worker.id + ' 处理任务 #' + result.taskId + ' 出错: ' + result.error, 'error');
                }
                
                // 发送结果到Subject流
                this.resultSubject.next(result);
                
                // 标记工作线程为空闲
                worker.status = 'idle';
                worker.currentTask = null;
                
                // 更新状态
                this.updateWorkerStatus();
                
                // 处理下一个任务
                this.processNextTask();
            }
            
            // 更新工作线程状态
            updateWorkerStatus() {
                const status = this.workers.map(worker => ({
                    id: worker.id,
                    status: worker.status,
                    currentTask: worker.currentTask
                }));
                
                this.workersStatusSubject.next(status);
            }
            
            // 创建Observable处理数据
            processData(dataType, data, simulateError = false) {
                // 如果数据为空，直接返回空Observable
                if (!data || data.length === 0) {
                    log('收到空数据，跳过处理', 'warn');
                    return of({ 
                        success: true, 
                        dataType, 
                        processedData: [], 
                        stats: {
                            count: 0,
                            min: 0,
                            max: 0,
                            mean: 0,
                            stdDev: 0,
                            processingTime: 0
                        }
                    });
                }
                
                log('收到 ' + data.length + ' 个 ' + dataType + ' 数据点待处理', 'info');
                
                // 创建任务批次 (每批次从50改为25个数据点，提高处理速度)
                const batchSize = 25;
                const batches = [];
                
                for (let i = 0; i < data.length; i += batchSize) {
                    const batchData = data.slice(i, i + batchSize);
                    const taskId = this.nextTaskId++;
                    
                    // 创建任务对象
                    const task = {
                        id: taskId,
                        dataType,
                        data: batchData,
                        simulateError
                    };
                    
                    // 添加到队列
                    this.taskQueue.push(task);
                    batches.push(taskId);
                    
                    log('创建 ' + dataType + ' 任务 #' + taskId + '，包含 ' + batchData.length + ' 个数据点', 'debug');
                }
                
                // 开始处理任务队列
                this.processNextTask();
                
                // 创建一个结果过滤器Observable，仅返回与这次批次相关的结果
                return this.resultSubject.pipe(
                    filter(result => batches.includes(result.taskId)),
                    // 限制只取这次批次的结果数量
                    take(batches.length)
                );
            }
            
            // 处理队列中的下一个任务
            processNextTask() {
                // 检查是否有空闲工作线程和待处理任务
                const idleWorker = this.workers.find(worker => worker.status === 'idle');
                
                if (idleWorker && this.taskQueue.length > 0) {
                    // 从队列中获取下一个任务
                    const task = this.taskQueue.shift();
                    
                    // 分配任务给工作线程
                    idleWorker.status = 'busy';
                    idleWorker.currentTask = {
                        id: task.id,
                        dataType: task.dataType,
                        dataCount: task.data.length
                    };
                    
                    // 更新状态
                    this.updateWorkerStatus();
                    
                    // 发送任务到工作线程
                    idleWorker.postMessage({
                        taskId: task.id,
                        dataType: task.dataType,
                        data: task.data
                    });
                    
                    log('分配 ' + task.dataType + ' 任务 #' + task.id + ' 给 Worker ' + idleWorker.id, 'debug');
                    
                    // 继续处理下一个任务 (如果有更多空闲工作线程)
                    this.processNextTask();
                }
            }
            
            // 获取当前队列长度
            getQueueLength() {
                return this.taskQueue.length;
            }
            
            // 获取工作线程状态Observable
            getWorkersStatus$() {
                return this.workersStatusSubject.asObservable();
            }
            
            // 终止所有工作线程
            terminateAll() {
                this.workers.forEach(worker => worker.terminate());
                this.workers = [];
                this.taskQueue = [];
                log('终止了所有工作线程', 'info');
            }
        }

        // --------------------------
        // 模拟的Angular服务
        // --------------------------
        
        // 数据管理服务 - 模拟@Injectable()服务
        class DataService {
            constructor(workerPool) {
                this.workerPool = workerPool;
                
                // 数据存储
                this.dataStore = {
                    dataA: [],
                    dataB: []
                };
                
                // 数据计数器
                this.dataCounters = {
                    dataA: 0,
                    dataB: 0
                };
                
                // 数据变化Subjects
                this.dataChangeSubjects = {
                    dataA: new ReplaySubject(1),
                    dataB: new ReplaySubject(1)
                };
                
                // 数据统计Subjects
                this.statsSubjects = {
                    dataA: new BehaviorSubject(null),
                    dataB: new BehaviorSubject(null)
                };
                
                // 合并所有数据统计信息
                this.allStats$ = combineLatest([
                    this.statsSubjects.dataA,
                    this.statsSubjects.dataB
                ]).pipe(
                    map(([statsA, statsB]) => ({
                        dataA: statsA,
                        dataB: statsB
                    }))
                );
                
                // 处理结果收集器
                this.processedDataStore = {
                    dataA: [],
                    dataB: []
                };
                
                // 处理后数据流
                this.processedData$ = {
                    dataA: new BehaviorSubject([]),
                    dataB: new BehaviorSubject([])
                };
                
                log('数据服务初始化完成', 'info');
            }
            
            // 初始化数据
            initData(dataType, count = 100) {
                log('初始化 ' + dataType + ' 数据，生成 ' + count + ' 个初始数据点', 'info');
                
                // 生成初始数据
                const initialData = generateRandomData(count, this.dataCounters[dataType]);
                this.dataCounters[dataType] += count;
                
                // 存储原始数据
                this.dataStore[dataType] = initialData;
                
                // 通知数据变化
                this.dataChangeSubjects[dataType].next(initialData);
                
                // 使用Worker处理数据
                return this.processDataWithWorker(dataType, initialData);
            }
            
            // 生成新数据
            generateNewData(dataType, count = 5) {
                // 增加默认生成的数据点数量，从5改为8-15
                const newCount = count || (Math.floor(Math.random() * 8) + 8);
                log('为 ' + dataType + ' 生成 ' + newCount + ' 个新数据点', 'debug');
                
                // 生成新数据点
                const newData = generateRandomData(newCount, this.dataCounters[dataType]);
                this.dataCounters[dataType] += newCount;
                
                // 添加到存储
                this.dataStore[dataType] = this.dataStore[dataType].concat(newData);
                
                // 应用数据缓存策略 (保留最新的1000个点)
                if (this.dataStore[dataType].length > 1000) {
                    this.dataStore[dataType] = this.dataStore[dataType].slice(-1000);
                }
                
                // 通知数据变化
                this.dataChangeSubjects[dataType].next(newData);
                
                // 返回新数据
                return newData;
            }
            
            // 使用Worker处理数据
            processDataWithWorker(dataType, data) {
                // 创建Observable
                return this.workerPool.processData(dataType, data, false).pipe(
                    // 合并多个批次的结果
                    scan((accumulated, current) => {
                        if (!current.success) {
                            // 如果处理失败，记录错误但不影响已累积数据
                            log(current.dataType + ' 数据处理错误: ' + current.error, 'error');
                            return accumulated;
                        }
                        
                        // 合并处理后的数据
                        return {
                            dataType: current.dataType,
                            processedData: accumulated.processedData.concat(current.processedData),
                            stats: current.stats // 使用最新的统计信息
                        };
                    }, { dataType, processedData: [], stats: null }),
                    // 处理完成后的操作
                    tap(result => {
                        if (result.stats) {
                            // 更新统计信息
                            this.statsSubjects[dataType].next(result.stats);
                        }
                        
                        // 合并到已处理数据存储
                        this.processedDataStore[dataType] = 
                            this.processedDataStore[dataType].concat(result.processedData);
                        
                        // 应用数据缓存策略 (保留最新的3000个点)
                        if (this.processedDataStore[dataType].length > 3000) {
                            this.processedDataStore[dataType] = 
                                this.processedDataStore[dataType].slice(-3000);
                        }
                        
                        // 发送更新后的完整处理数据
                        this.processedData$[dataType].next(this.processedDataStore[dataType]);
                    }),
                    // 捕获错误
                    catchError(error => {
                        log('处理 ' + dataType + ' 数据时发生错误: ' + error.message, 'error');
                        return of({ dataType, processedData: [], stats: null });
                    })
                );
            }
            
            // 导入外部数据
            importExternalData(dataType, jsonData) {
                try {
                    // 解析JSON
                    let data = Array.isArray(jsonData) ? jsonData : JSON.parse(jsonData);
                    
                    // 验证数据格式
                    if (!Array.isArray(data)) {
                        throw new Error('数据必须是数组格式');
                    }
                    
                    // 确保每个数据点都有x和y属性
                    data = data.map((item, index) => {
                        if (typeof item !== 'object' || item === null) {
                            item = {};
                        }
                        
                        return {
                            x: item.x !== undefined ? item.x : this.dataCounters[dataType] + index,
                            y: item.y !== undefined ? Number(item.y) : 0
                        };
                    });
                    
                    // 更新计数器
                    if (data.length > 0) {
                        const maxX = Math.max(...data.map(item => item.x));
                        this.dataCounters[dataType] = Math.max(this.dataCounters[dataType], maxX + 1);
                    }
                    
                    // 存储原始数据
                    this.dataStore[dataType] = this.dataStore[dataType].concat(data);
                    
                    // 应用数据缓存策略
                    if (this.dataStore[dataType].length > 1000) {
                        this.dataStore[dataType] = this.dataStore[dataType].slice(-1000);
                    }
                    
                    // 通知数据变化
                    this.dataChangeSubjects[dataType].next(data);
                    
                    log('成功导入 ' + data.length + ' 个 ' + dataType + ' 数据点', 'info');
                    return data;
                } catch (error) {
                    log('导入数据失败: ' + error.message, 'error');
                    throw error;
                }
            }
            
            // 获取数据变化Observable
            getDataChanges$(dataType) {
                return this.dataChangeSubjects[dataType].asObservable();
            }
            
            // 获取处理后数据Observable
            getProcessedData$(dataType) {
                return this.processedData$[dataType].asObservable();
            }
            
            // 获取统计信息Observable
            getStats$(dataType) {
                return this.statsSubjects[dataType].asObservable();
            }
            
            // 获取所有统计信息Observable
            getAllStats$() {
                return this.allStats$;
            }
        }
        
        // 可视化服务 - 模拟@Injectable()服务
        class VisualizationService {
            constructor() {
                // SVG元素缓存
                this.svgElements = {};
                
                // 图表配置
                this.chartConfig = {
                    width: 0,
                    height: 0,
                    padding: { top: 20, right: 30, bottom: 30, left: 40 },
                    transition: 300
                };
                
                // 数据缩放信息
                this.scales = {
                    dataA: { minX: 0, maxX: 100, minY: 0, maxY: 100 },
                    dataB: { minX: 0, maxX: 100, minY: 0, maxY: 100 }
                };
                
                // 添加额外配置 - 启用动画和缓动
                this.enableAnimation = true;
                this.animationDuration = 300; // 毫秒
                
                log('可视化服务初始化完成', 'info');
            }
            
            // 初始化图表
            initCharts() {
                // 初始化每个图表
                this.initChart('dataA', 'chart-a');
                this.initChart('dataB', 'chart-b');
                
                // 监听窗口大小变化
                fromEvent(window, 'resize')
                    .pipe(debounceTime(300))
                    .subscribe(() => {
                        this.updateChartSizes();
                    });
                
                // 初始设置尺寸
                this.updateChartSizes();
            }
            
            // 初始化单个图表
            initChart(dataType, svgId) {
                const svg = document.getElementById(svgId);
                if (!svg) {
                    log('找不到SVG元素: ' + svgId, 'error');
                    return;
                }
                
                // 清空SVG
                svg.innerHTML = '';
                
                // 创建SVG组
                const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                mainGroup.setAttribute('class', 'main-group');
                svg.appendChild(mainGroup);
                
                // 创建坐标轴组
                const axisGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                axisGroup.setAttribute('class', 'axis-group');
                mainGroup.appendChild(axisGroup);
                
                // 创建X轴
                const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                xAxis.setAttribute('class', 'x-axis');
                axisGroup.appendChild(xAxis);
                
                // 创建Y轴
                const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                yAxis.setAttribute('class', 'y-axis');
                axisGroup.appendChild(yAxis);
                
                // 创建数据组
                const dataGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                dataGroup.setAttribute('class', 'data-group');
                mainGroup.appendChild(dataGroup);
                
                // 创建数据路径
                const dataPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                dataPath.setAttribute('class', 'data-line');
                dataPath.setAttribute('fill', 'none');
                dataPath.setAttribute('stroke', dataType === 'dataA' ? '#007bff' : '#28a745');
                dataPath.setAttribute('stroke-width', '2');
                dataGroup.appendChild(dataPath);
                
                // 存储SVG元素引用
                this.svgElements[dataType] = {
                    svg,
                    mainGroup,
                    axisGroup,
                    xAxis,
                    yAxis,
                    dataGroup,
                    dataPath
                };
                
                log('初始化图表: ' + dataType, 'debug');
            }
            
            // 更新图表尺寸
            updateChartSizes() {
                // 遍历所有图表
                Object.keys(this.svgElements).forEach(dataType => {
                    const { svg } = this.svgElements[dataType];
                    const rect = svg.getBoundingClientRect();
                    
                    // 更新图表配置
                    this.chartConfig.width = rect.width;
                    this.chartConfig.height = rect.height;
                    
                    // 设置SVG视口
                    svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
                    
                    // 更新转换矩阵
                    const { padding } = this.chartConfig;
                    const transform = `translate(${padding.left}, ${padding.top})`;
                    this.svgElements[dataType].mainGroup.setAttribute('transform', transform);
                });
                
                log('更新图表尺寸', 'debug');
            }
            
            // 更新数据显示
            updateChart(dataType, data) {
                if (!this.svgElements[dataType]) {
                    log('找不到图表: ' + dataType, 'error');
                    return;
                }
                
                if (!data || data.length === 0) {
                    log(dataType + ' 无数据可显示', 'warn');
                    return;
                }
                
                // 获取SVG元素
                const { svg, dataPath, xAxis, yAxis } = this.svgElements[dataType];
                const { width, height, padding } = this.chartConfig;
                
                // 计算可用空间
                const availWidth = width - padding.left - padding.right;
                const availHeight = height - padding.top - padding.bottom;
                
                // 分析数据范围 - 改进计算逻辑，增加平滑过渡
                const minX = Math.min(...data.map(d => d.x));
                const maxX = Math.max(...data.map(d => d.x));
                
                // 计算新的Y值范围
                const minY = Math.min(...data.map(d => d.y));
                const maxY = Math.max(...data.map(d => d.y));
                
                // 平滑过渡的缩放信息
                const currentScale = this.scales[dataType];
                if (currentScale.minY !== 0 || currentScale.maxY !== 0) {
                    // 如果有之前的值，平滑过渡（添加一点插值）
                    const interp = 0.3; // 插值系数
                    currentScale.minX = currentScale.minX * (1-interp) + minX * interp;
                    currentScale.maxX = currentScale.maxX * (1-interp) + maxX * interp;
                    currentScale.minY = currentScale.minY * (1-interp) + minY * interp;
                    currentScale.maxY = currentScale.maxY * (1-interp) + maxY * interp;
                } else {
                    // 首次设置值
                    currentScale.minX = minX;
                    currentScale.maxX = maxX;
                    currentScale.minY = minY;
                    currentScale.maxY = maxY;
                }
                
                // 添加一些边距
                const xDomain = [currentScale.minX, currentScale.maxX + (currentScale.maxX - currentScale.minX) * 0.1];
                const yDomain = [
                    currentScale.minY - (currentScale.maxY - currentScale.minY) * 0.1, 
                    currentScale.maxY + (currentScale.maxY - currentScale.minY) * 0.1
                ];
                
                // 创建比例尺函数
                const xScale = (x) => {
                    return availWidth * (x - xDomain[0]) / (xDomain[1] - xDomain[0]);
                };
                
                const yScale = (y) => {
                    return availHeight - (availHeight * (y - yDomain[0]) / (yDomain[1] - yDomain[0]));
                };
                
                // 创建路径数据 - 使用更平滑的曲线
                let pathData = `M ${xScale(data[0].x)} ${yScale(data[0].y)}`;
                
                // 使用曲线绘制而非直线 - 提高视觉流畅度
                for (let i = 1; i < data.length; i++) {
                    // 当数据点较少时使用曲线，数据点多时使用直线以提高性能
                    if (data.length < 500) {
                        // 贝塞尔曲线控制点
                        const x1 = xScale(data[i-1].x) + (xScale(data[i].x) - xScale(data[i-1].x)) / 3;
                        const y1 = yScale(data[i-1].y);
                        const x2 = xScale(data[i].x) - (xScale(data[i].x) - xScale(data[i-1].x)) / 3;
                        const y2 = yScale(data[i].y);
                        
                        pathData += ` C ${x1} ${y1}, ${x2} ${y2}, ${xScale(data[i].x)} ${yScale(data[i].y)}`;
                    } else {
                        // 数据点多时使用直线，提高性能
                        pathData += ` L ${xScale(data[i].x)} ${yScale(data[i].y)}`;
                    }
                }
                
                // 设置曲线过渡动画
                if (this.enableAnimation) {
                    dataPath.style.transition = `d ${this.animationDuration}ms ease`;
                }
                
                // 更新路径
                dataPath.setAttribute('d', pathData);
                
                // 更新X轴
                xAxis.innerHTML = '';
                const xTickCount = 5;
                const xStep = (xDomain[1] - xDomain[0]) / (xTickCount - 1);
                
                for (let i = 0; i < xTickCount; i++) {
                    const tickValue = xDomain[0] + i * xStep;
                    const tickX = xScale(tickValue);
                    
                    // 创建刻度线
                    const tickLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tickLine.setAttribute('x1', tickX);
                    tickLine.setAttribute('y1', availHeight);
                    tickLine.setAttribute('x2', tickX);
                    tickLine.setAttribute('y2', availHeight + 6);
                    tickLine.setAttribute('stroke', '#666');
                    xAxis.appendChild(tickLine);
                    
                    // 创建刻度文本
                    const tickText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    tickText.setAttribute('x', tickX);
                    tickText.setAttribute('y', availHeight + 20);
                    tickText.setAttribute('text-anchor', 'middle');
                    tickText.setAttribute('font-size', '12px');
                    tickText.textContent = Math.round(tickValue);
                    xAxis.appendChild(tickText);
                }
                
                // 更新Y轴
                yAxis.innerHTML = '';
                const yTickCount = 5;
                const yStep = (yDomain[1] - yDomain[0]) / (yTickCount - 1);
                
                for (let i = 0; i < yTickCount; i++) {
                    const tickValue = yDomain[0] + i * yStep;
                    const tickY = yScale(tickValue);
                    
                    // 创建刻度线
                    const tickLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    tickLine.setAttribute('x1', -6);
                    tickLine.setAttribute('y1', tickY);
                    tickLine.setAttribute('x2', 0);
                    tickLine.setAttribute('y2', tickY);
                    tickLine.setAttribute('stroke', '#666');
                    yAxis.appendChild(tickLine);
                    
                    // 创建刻度文本
                    const tickText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    tickText.setAttribute('x', -10);
                    tickText.setAttribute('y', tickY + 4);
                    tickText.setAttribute('text-anchor', 'end');
                    tickText.setAttribute('font-size', '12px');
                    tickText.textContent = Math.round(tickValue);
                    yAxis.appendChild(tickText);
                }
                
                // 添加网格线 (仅示例，未完全实现)
                // ...
                
                log('更新 ' + dataType + ' 图表，显示 ' + data.length + ' 个数据点', 'debug');
            }
        }
        
        // --------------------------
        // 模拟的Angular组件
        // --------------------------
        
        // 仪表盘组件 - 模拟@Component装饰器
        class DashboardComponent {
            constructor(dataService, visualizationService) {
                this.dataService = dataService;
                this.visualService = visualizationService;
                
                // 系统运行状态
                this.running = false;
                
                // 系统更新间隔 (毫秒) - 从2000ms改为500ms使数据更新更频繁
                this.updateInterval = 500;
                
                // 定时器引用
                this.updateTimer = null;
                
                // 销毁Subject
                this.destroy$ = new Subject();
                
                log('仪表盘组件已创建', 'info');
            }
            
            // 初始化组件
            init() {
                log('初始化仪表盘组件', 'info');
                
                // 初始化图表
                this.visualService.initCharts();
                
                // 设置事件监听器
                this.setupEventListeners();
                
                // 初始化UI更新订阅
                this.setupSubscriptions();
            }
            
            // 设置事件监听
            setupEventListeners() {
                // 开始按钮
                const startBtn = document.getElementById('startBtn');
                fromEvent(startBtn, 'click')
                    .pipe(takeUntil(this.destroy$))
                    .subscribe(() => this.startSystem());
                
                // 停止按钮
                const stopBtn = document.getElementById('stopBtn');
                fromEvent(stopBtn, 'click')
                    .pipe(takeUntil(this.destroy$))
                    .subscribe(() => this.stopSystem());
                
                // 导入数据按钮
                const importDataBtn = document.getElementById('importDataBtn');
                fromEvent(importDataBtn, 'click')
                    .pipe(takeUntil(this.destroy$))
                    .subscribe(() => this.importData());
                
                log('设置了事件监听器', 'debug');
            }
            
            // 设置数据订阅
            setupSubscriptions() {
                // 订阅数据A的处理结果
                this.dataService.getProcessedData$('dataA')
                    .pipe(
                        filter(data => data && data.length > 0),
                        takeUntil(this.destroy$)
                    )
                    .subscribe(data => {
                        this.visualService.updateChart('dataA', data);
                    });
                
                // 订阅数据B的处理结果
                this.dataService.getProcessedData$('dataB')
                    .pipe(
                        filter(data => data && data.length > 0),
                        takeUntil(this.destroy$)
                    )
                    .subscribe(data => {
                        this.visualService.updateChart('dataB', data);
                    });
                
                // 订阅统计信息更新
                this.dataService.getAllStats$()
                    .pipe(
                        takeUntil(this.destroy$)
                    )
                    .subscribe(stats => {
                        this.updateStatsPanel(stats);
                    });
                
                // 订阅工作线程状态更新
                workerPool.getWorkersStatus$()
                    .pipe(
                        takeUntil(this.destroy$)
                    )
                    .subscribe(status => {
                        this.updateWorkerStatusPanel(status);
                    });
                
                // 订阅日志消息
                logSubject
                    .pipe(
                        takeUntil(this.destroy$)
                    )
                    .subscribe(logEntry => {
                        this.updateLogPanel(logEntry);
                    });
                
                log('设置了数据订阅', 'debug');
            }
            
            // 启动系统
            startSystem() {
                if (this.running) return;
                
                log('启动系统', 'info');
                this.running = true;
                
                // 更新按钮状态
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                // 初始化数据 - 增加初始数据量从100到200
                const initDataA$ = this.dataService.initData('dataA', 200);
                const initDataB$ = this.dataService.initData('dataB', 200);
                
                // 合并初始化流，等待所有数据处理完成
                concat(initDataA$, initDataB$)
                    .pipe(
                        takeUntil(this.destroy$)
                    )
                    .subscribe({
                        complete: () => {
                            log('初始数据处理完成，开始定时更新', 'info');
                            
                            // 设置定时更新
                            this.startPeriodicUpdates();
                        }
                    });
            }
            
            // 开始定时更新
            startPeriodicUpdates() {
                this.updateTimer = setInterval(() => {
                    if (!this.running) return;
                    
                    // 为每个数据类型生成新数据
                    const generateAndProcess = (dataType) => {
                        // 随机生成8-15条新数据点
                        const newCount = Math.floor(Math.random() * 8) + 8;
                        const newData = this.dataService.generateNewData(dataType, newCount);
                        
                        // 处理新数据并添加错误重试功能
                        return this.dataService.processDataWithWorker(dataType, newData).pipe(
                            // 添加最多重试3次的功能
                            retry(3),
                            catchError(error => {
                                log('处理 ' + dataType + ' 数据时出错: ' + error.message, 'error');
                                return of(null);
                            })
                        );
                    };
                    
                    // 并行处理A和B数据
                    merge(
                        generateAndProcess('dataA'),
                        generateAndProcess('dataB')
                    ).pipe(
                        takeUntil(this.destroy$)
                    ).subscribe();
                    
                }, this.updateInterval);
            }
            
            // 停止系统
            stopSystem() {
                if (!this.running) return;
                
                log('停止系统', 'info');
                this.running = false;
                
                // 清除定时器
                if (this.updateTimer) {
                    clearInterval(this.updateTimer);
                    this.updateTimer = null;
                }
                
                // 更新按钮状态
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
            }
            
            // 导入数据
            importData() {
                const dataType = document.getElementById('dataTypeSelect').value;
                const jsonInput = document.getElementById('jsonDataInput').value.trim();
                
                if (!jsonInput) {
                    log('请输入有效的JSON数据', 'warn');
                    return;
                }
                
                try {
                    // 使用服务导入数据
                    const importedData = this.dataService.importExternalData(dataType, jsonInput);
                    
                    // 处理导入的数据
                    this.dataService.processDataWithWorker(dataType, importedData)
                        .pipe(
                            takeUntil(this.destroy$)
                        )
                        .subscribe({
                            complete: () => {
                                // 隐藏导入模态框
                                const importModal = bootstrap.Modal.getInstance(document.getElementById('importModal'));
                                if (importModal) {
                                    importModal.hide();
                                }
                                
                                // 清空输入框
                                document.getElementById('jsonDataInput').value = '';
                                
                                log('成功导入并处理数据', 'info');
                            }
                        });
                } catch (error) {
                    log('导入数据失败: ' + error.message, 'error');
                }
            }
            
            // 更新统计面板
            updateStatsPanel(stats) {
                const statsPanel = document.getElementById('statsPanel');
                if (!statsPanel) return;
                
                let html = '';
                
                // 数据A统计
                html += '<div class="mb-3">';
                html += '<h6>数据流A</h6>';
                
                if (stats.dataA) {
                    html += '<div class="row">';
                    html += '<div class="col-6">数据点数: ' + stats.dataA.count + '</div>';
                    html += '<div class="col-6">平均值: ' + stats.dataA.mean.toFixed(2) + '</div>';
                    html += '<div class="col-6">最小值: ' + stats.dataA.min.toFixed(2) + '</div>';
                    html += '<div class="col-6">最大值: ' + stats.dataA.max.toFixed(2) + '</div>';
                    html += '<div class="col-12">标准差: ' + stats.dataA.stdDev.toFixed(2) + '</div>';
                    html += '</div>';
                } else {
                    html += '<div>无数据</div>';
                }
                
                html += '</div>';
                
                // 数据B统计
                html += '<div>';
                html += '<h6>数据流B</h6>';
                
                if (stats.dataB) {
                    html += '<div class="row">';
                    html += '<div class="col-6">数据点数: ' + stats.dataB.count + '</div>';
                    html += '<div class="col-6">平均值: ' + stats.dataB.mean.toFixed(2) + '</div>';
                    html += '<div class="col-6">最小值: ' + stats.dataB.min.toFixed(2) + '</div>';
                    html += '<div class="col-6">最大值: ' + stats.dataB.max.toFixed(2) + '</div>';
                    html += '<div class="col-12">标准差: ' + stats.dataB.stdDev.toFixed(2) + '</div>';
                    html += '</div>';
                } else {
                    html += '<div>无数据</div>';
                }
                
                html += '</div>';
                
                statsPanel.innerHTML = html;
            }
            
            // 更新工作线程状态面板
            updateWorkerStatusPanel(workers) {
                const statusPanel = document.getElementById('workerStatusPanel');
                if (!statusPanel) return;
                
                let html = '';
                
                for (const worker of workers) {
                    const statusClass = worker.status === 'idle' ? 'text-success' : 'text-warning';
                    
                    html += '<div class="worker-card">';
                    html += '<div class="d-flex justify-content-between">';
                    html += '<strong>Worker #' + worker.id + '</strong>';
                    html += '<span class="' + statusClass + '">' + (worker.status === 'idle' ? '空闲' : '忙碌') + '</span>';
                    html += '</div>';
                    
                    if (worker.currentTask) {
                        html += '<div class="mt-1">';
                        html += '任务: #' + worker.currentTask.id + ' ' + worker.currentTask.dataType;
                        html += ' (' + worker.currentTask.dataCount + ' 数据点)';
                        html += '</div>';
                    }
                    
                    html += '</div>';
                }
                
                html += '<div class="mt-2">';
                html += '队列中任务: ' + workerPool.getQueueLength();
                html += '</div>';
                
                statusPanel.innerHTML = html;
            }
            
            // 更新日志面板
            updateLogPanel(logEntry) {
                const logContainer = document.getElementById('logContainer');
                if (!logContainer) return;
                
                const logItem = document.createElement('div');
                logItem.className = 'log-entry ' + logEntry.level;
                logItem.innerHTML = `<small>[${logEntry.timestamp}]</small> ${logEntry.message}`;
                
                logContainer.appendChild(logItem);
                logContainer.scrollTop = logContainer.scrollHeight;
                
                // 保持日志条目在合理范围内
                while (logContainer.children.length > 100) {
                    logContainer.removeChild(logContainer.firstChild);
                }
            }
            
            // 销毁组件
            destroy() {
                log('销毁仪表盘组件', 'info');
                
                // 停止系统
                this.stopSystem();
                
                // 通知所有订阅停止
                this.destroy$.next();
                this.destroy$.complete();
            }
        }
        
        // --------------------------
        // 主程序入口
        // --------------------------
        
        // 初始化工作线程池
        const workerPool = new WorkerPool();
        
        // 初始化服务
        const dataService = new DataService(workerPool);
        const visualService = new VisualizationService();
        
        // 初始化组件
        const dashboardComponent = new DashboardComponent(dataService, visualService);
        
        // 当DOM加载完成后启动应用
        document.addEventListener('DOMContentLoaded', () => {
            log('DOM加载完成，启动应用', 'info');
            dashboardComponent.init();
        });
        
        // 处理页面卸载
        window.addEventListener('beforeunload', () => {
            dashboardComponent.destroy();
            workerPool.terminateAll();
        });
    </script>
</body>
</html> 